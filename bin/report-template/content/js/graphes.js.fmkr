$(document).ready(function() {
    
	$(".click-title").mouseenter( function(	e){
		e.preventDefault();
		this.style.cursor="pointer";
	});
	$(".click-title").mousedown( function(event){
		event.preventDefault();
	});
	
	try{
		bbq();
	} catch(e){}
	try{
		btot();
	} catch(e){}
	try{
		rtp();
	} catch(e){}
	$(".portlet-header").css("cursor", "auto");
});

var b1 = false;
var b2 = false;
var b3 = false;
var b4 = false;
var b5 = false;
var b6 = false;
var b7 = false;
var b8 = false;
var b9 = false;
var b10 = false;
var b11 = false;
var chiffre = 0;

var overviewOptions = {
	series: {
		lines: { show: true, lineWidth: 1 },
		shadowSize: 0
	},
	xaxis: { 
		mode: "time",
		timeformat: "%H:%M:%S",
	},
	yaxis: {
		min: 0,
	},
	grid: {
		color: "#999"
	},
	selection: {
		mode: "xy"
	},
	legend: {
		show: false
	}
};

// Fix time stamps
function fixTimeStamps(data, offset){
	$.each(data, function(key, val) {
		$.each(val.data, function(index, coord) {
			coord[0] += offset;
		});
	});
}

// Prepare DOM items to add zoom on the specified graph
function setGraphZoomable(graphSelector, overviewSelector, options){
	var graph = $(graphSelector);
	var overview = $(overviewSelector);
	 
	// Ignore mouse down event
	graph.bind("mousedown", function() { return false; });
	overview.bind("mousedown", function() { return false; });
	
	// now connect the two
	graph.bind("plotselected", function (event, ranges) {
		var self = $(this);
		
		// clamp the zooming to prevent infinite zoom
		if (ranges.xaxis.to - ranges.xaxis.from < 0.00001) {
			ranges.xaxis.to = ranges.xaxis.from + 0.00001;
		}
		if (ranges.yaxis.to - ranges.yaxis.from < 0.00001) {
			ranges.yaxis.to = ranges.yaxis.from + 0.00001;
		}
		
		// Do the zooming
		$.plot(self, self.data('plot').getData(), 
			$.extend(true, {}, options, {
				xaxis: { min: ranges.xaxis.from, max: ranges.xaxis.to },
				yaxis: { min: ranges.yaxis.from, max: ranges.yaxis.to }
			}));
	});
		
	// don't fire event on the overview to prevent eternal loop
	overview.bind("plotselected", function (event, ranges) {
		$(graphSelector).data('plot').setSelection(ranges);
	});
}
	
//Response times percentiles
function rtp(bool, below) {
	var data = ${responseTimePercentiles.values};
    var options = {
        series: {
            points: { show: false }
        },
        legend: {
        	noColumns: 2,
        	show: true,
        	container: '#legendResponseTimePercentiles'
        },
        xaxis: {
        	min: ${responseTimePercentiles.minX?c},
			max: ${responseTimePercentiles.maxX?c},
			tickDecimals: 1,
			axisLabel: "Percentiles",
			axisLabelUseCanvas: true,
			axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
		},
        yaxis: { 
			min: ${responseTimePercentiles.minY?c},
			max: ${responseTimePercentiles.maxY?c},
			axisLabel: "Percentile value in ms",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
			
		},
		grid: {
            hoverable: true //IMPORTANT! this is needed for tooltip to work
        },
        tooltip: true,
        tooltipOpts: {
            content: "%s for %x.2 was %y"
        },
        selection: { mode: "x" },
		stack: true
    };

    var placeholder = $("#flot-response-times-percentiles");

	var i = 0;
	$.each(data, function(key, val) {
		val.color = i;
		++i;
	});
	
	var choiceContainer = $("#choicesResponseTimePercentiles");
	if ( bool == false ){
		plotAccordingToChoices();
	} else {
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		$('#bodyPercentiles .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
		}
		function plotAccordingToChoices() {
			var datasets = [];
			var i = 0;
			choiceContainer.find("input:checked").each(function () {
				var key = $(this).attr("name");
				if (key == data[key].label){
					datasets.push(data[key]);
					datasets[i].threshold.below=chiffre;
					datasets[i].threshold.color=$("#slider-vertical").children("div").css("background-color");
					i++;
				}
			});

			$.plot(placeholder, datasets, options);
			$("#collapseResponseTimePercentiles #legendResponseTimePercentiles").children().css("border", "1px solid #888888");
		}
}

// Response time distribution
function rtd(bool) {
	var data = ${responseTimeDistribution.values};
	var options = {
		legend: { noColumns: 2,show: true, container: '#legendResponseTimeDistribution' },
		xaxis:{
			axisLabel: "Response times in ms",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
		},
		yaxis: {
			axisLabel: "Number of responses",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
		},
		bars : {
			show: true,
			barWidth: ${responseTimeDistribution.granularity?c}
		},
		grid: {
            hoverable: true //IMPORTANT! this is needed for tooltip to work
        },
        tooltip: true,
        tooltipOpts: {
            content: function(label, xval, yval, flotItem){
            	return yval + " responses for " + label + " were between " + xval + " and " + (xval + ${responseTimeDistribution.granularity?c}) + " ms";
            }
        }
    };
	
	var i = 0;
	var choiceContainer = $("#choicesResponseTimeDistribution");
	if (bool == false){
		plotAccordingToChoices();
	}else{
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		$('#footerRTD .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
	function plotAccordingToChoices() {
		$.plot($("#flot-response-time-distribution"), prepareData( data, choiceContainer), options);
	}
};

// Active Threads Over Time
function tsot(bool) {
	var data = ${activeThreadsOverTime.values};
	var options = {
        series: {
            lines: {
                show: true
            },
            points: {
				show: true
            }
        },
		xaxis: {
			min: ${activeThreadsOverTime.minX?c} + ${timeZoneOffset?c},
			max: ${activeThreadsOverTime.maxX?c} + ${timeZoneOffset?c},
            mode: "time",
			timeformat: "%H:%M:%S",
			axisLabel: getElapsedTimeLabel(${activeThreadsOverTime.granularity?c}),
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
        },
		yaxis: { 
			min: ${activeThreadsOverTime.minY?c},
			max: ${activeThreadsOverTime.maxY?c},
			axisLabel: "Number of active threads",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20
        },
		legend: {
			noColumns: 6,
			show: true,
			container: '#legendActiveThreadsOverTime'
		},
		grid: {
            hoverable: true //IMPORTANT! this is needed for tooltip to work
        },
        tooltip: true,
        tooltipOpts: {
            content: "%s for %x was %y"
        }
    };

    // hard-code color indices to prevent them from shifting as
	// countries are turned on/off
	var i = 0;
	$.each(data, function(key, val) {
		val.color = i;
		++i;
	});
	
	fixTimeStamps(data, ${timeZoneOffset?c});
	
	var dataset = [];
	var choiceContainer = $("#choicesActiveThreadsOverTime");
	if( bool == false ) {
		plotAccordingToChoices();
	}else{
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		setGraphZoomable("#flotActiveThreadsOverTime", "#overviewActiveThreadsOverTime", options)
		$('#footerTSOT .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
	function plotAccordingToChoices() {
		dataset = prepareData( data, choiceContainer);
		$.plot($("#flotActiveThreadsOverTime"), dataset, options);
		
		// setup overview
		$.plot("#overviewActiveThreadsOverTime", dataset, overviewOptions);
	}
};

// Response Time Per Sample
function hb(bool) {
		var ticks = ${responseTimePerSample.sampleNames};
		var dataSet = ${responseTimePerSample.values};
 
        var options = {
            series: {
                bars: {
                    show: true
                }
            },
            bars: {
                align: "center",
                barWidth: 0.5,
                horizontal: true,
                fillColor: { colors: [{ opacity: 0.5 }, { opacity: 1}] },
                lineWidth: 1
            },
            xaxis: {
                max: ${responseTimePerSample.maxX?c},
                axisLabel: "Response Time in ms",
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,
                tickColor: "white",
                tickFormatter: function (v, axis) {
                    return $.formatNumber(v, { format: "#,###", locale: "us" });
                },
                color: "black"
            },
            yaxis: {
                tickColor: "white",
                ticks: ticks,
                color: "black"
            },
            legend: {
                noColumns: 0,
                labelBoxBorderColor: "#858585",
                container: '#legendHorizontalBar'
            },
            grid: {
                hoverable: true,
                borderWidth: 2,
                backgroundColor: { colors: ["white", "white"] }
            }
        };
 
       
        // hard-code color indices to prevent them from shifting as
		// countries are turned on/off
		
		var choiceContainer = $("#choicesResponseTimePerSample");
		if (bool == false){
			plotAccordingToChoices();
		} else {
			createLegend(dataSet, choiceContainer);
			choiceContainer.find("input").click(plotAccordingToChoices);
			plotAccordingToChoices();
			$('#footerRTPS .legendColorBox > div').each(function(i){
				$(this).clone().prependTo(choiceContainer.find("li").eq(i));
			});
		}
		function plotAccordingToChoices() {
			$.plot($("#flot-horizontal-bar"), prepareData( dataSet, choiceContainer), options);
		}
   
        var previousPoint = null, previousLabel = null;
 
        $.fn.UseTooltip = function () {
            $(this).bind("plothover", function (event, pos, item) {
                if (item) {
                    if ((previousLabel != item.series.label) ||
                 (previousPoint != item.dataIndex)) {
                        previousPoint = item.dataIndex;
                        previousLabel = item.series.label;
                        $("#tooltip").remove();
 
                        var x = item.datapoint[0];
                        var y = item.datapoint[1];
 
                        var color = item.series.color;
 
                        showTooltip(item.pageX,
                        item.pageY,
                        color,
                        "<strong>" + item.series.label + "</strong><br>" + item.series.yaxis.ticks[y].label +
                        " : <strong>" + $.formatNumber(x, { format: "#,###", locale: "us" }) + "</strong> ms");
                    }
                } else {
                    $("#tooltip").remove();
                    previousPoint = null;
                }
            });
        };
 
        function showTooltip(x, y, color, contents) {
            $('<div id="tooltip">' + contents + '</div>').css({
                position: 'absolute',
                display: 'none',
                top: y - 10,
                left: x + 10,
                border: '2px solid ' + color,
                padding: '3px',
                'font-size': '9px',
                'border-radius': '5px',
                'background-color': '#fff',
                'font-family': 'Verdana, Arial, Helvetica, Tahoma, sans-serif',
                opacity: 0.9
            }).appendTo("body").fadeIn(200);
        }
	
	$("#flot-horizontal-bar").UseTooltip();
};


// Times vs threads
function tvt(bool){
		var data = ${timeVsThreads.values};
        var options = {
            series: {
                lines: {
                    show: true
                },
                points: {
                    show: true
                }
            },
			xaxis: {
				min: ${timeVsThreads.minX?c},
				max: ${timeVsThreads.maxX?c},
                axisLabel: "Number of active threads",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20,
			},
			yaxis: {
				min: ${timeVsThreads.minY?c},
				max: ${timeVsThreads.maxY?c},
                axisLabel: "Average response times in ms",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20
			},
			
			legend: { noColumns: 2,show: true, container: '#legendTimeVsThreads' },
			grid: {
                hoverable: true //IMPORTANT! this is needed for tooltip to work
            },
            tooltip: true,
            tooltipOpts: {
                content: "%s for %x.2 was %y.2",
                onHover: function(flotItem, $tooltipEl) {
                }
            }
        };
		
		var i = 0;
		
		var choiceContainer = $("#choicesTimeVsThreads");
		if(bool == false){
			plotAccordingToChoices();
		}else{
		
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		
		plotAccordingToChoices();
		
		$('#footerTVT .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
		}
		function plotAccordingToChoices() {
			$.plot($("#flot-times-vs-threads"), prepareData( data, choiceContainer), options);
		}
};


//Bytes throughput Over Time
function btot(bool) {
		var data = ${bytesThroughputOverTime.values};
		var options = {
			series: {
				lines: {
					show: true
				},
				points: {
					show: true
				}
			},
			xaxis: {
				min: ${bytesThroughputOverTime.minX?c} + ${timeZoneOffset?c},
				max: ${bytesThroughputOverTime.maxX?c} + ${timeZoneOffset?c},
				mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${bytesThroughputOverTime.granularity?c}) ,
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,
			},
			yaxis: { 
				min: ${bytesThroughputOverTime.minY?c},
				max: ${bytesThroughputOverTime.maxY?c},
				axisLabel: "Bytes/sec",
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,			
			},
			legend: {
				noColumns: 2,
				show: true,
				container: '#legendBytesThroughputOverTime'
			},
			selection: { 
				mode: "xy"
			},
			grid: {
				hoverable: true //IMPORTANT! this is needed for tooltip to work
			},
			tooltip: true,
			tooltipOpts: {
				content: "%s for %x was %y"
			}
		};

		// hard-code color indices to prevent them from shifting as
		// countries are turned on/off
		var i = 0;
		$.each(data, function(key, val) {
			val.color = i;
			++i;
		});
		
		fixTimeStamps(data, ${timeZoneOffset?c});
		
		var dataset = [];
		var choiceContainer = $("#choicesBytesThroughputOverTime");
		if( bool == false){
			plotAccordingToChoices();
		}else{
			createLegend(data, choiceContainer);
			choiceContainer.find("input").click(plotAccordingToChoices);
			plotAccordingToChoices();
			setGraphZoomable("#flotBytesThroughputOverTime", "#overviewBytesThroughputOverTime", options)
			$('#footerBytes .legendColorBox > div').each(function(i){
				$(this).clone().prependTo(choiceContainer.find("li").eq(i));
			});
		}
		function plotAccordingToChoices() {
			dataset = prepareData( data, choiceContainer);
			$.plot($("#flotBytesThroughputOverTime"), dataset, options);
			
			// setup overview
			$.plot($("#overviewBytesThroughputOverTime"), dataset, overviewOptions);
		}
}

//Response Time Over Time
function rtot(bool) {
    		
	var data = ${responseTimesOverTime.values};
	var options = {
        series: {
            lines: {
                show: true
            },
            points: {
                show: true
            }
        },
		xaxis: {
			min: ${responseTimesOverTime.minX?c} + ${timeZoneOffset?c},
			max: ${responseTimesOverTime.maxX?c} + ${timeZoneOffset?c},
            mode: "time",
			timeformat: "%H:%M:%S",
			axisLabel: getElapsedTimeLabel(${responseTimesOverTime.granularity?c}),
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
        },
		yaxis: { 
			min: ${responseTimesOverTime.minY?c},
			max: ${responseTimesOverTime.maxY?c},
			axisLabel: "Response time in ms",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
		},
		legend: {
			noColumns: 2,
			show: true,
			container: '#legendResponseTimesOverTime'
		},
		selection: { 
			mode: "x"
		},
		grid: {
            hoverable: true //IMPORTANT! this is needed for tooltip to work
        },
        tooltip: true,
        tooltipOpts: {
            content: "%s for %x was %y"
        }
    };

    // hard-code color indices to prevent them from shifting as
	// countries are turned on/off
	var i = 0;
	$.each(data, function(key, val) {
		val.color = i;
		++i;
	});

	fixTimeStamps(data, ${timeZoneOffset?c});
	
	var dataset = [];
	var choiceContainer = $("#choicesResponseTimesOverTime");
	if( bool == false){
		plotAccordingToChoices();
	}else{
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		setGraphZoomable("#flotResponseTimesOverTime", "#overviewResponseTimeOverTime", options);
		$('#footerRTOT .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
	function plotAccordingToChoices() {
		dataset = prepareData(data, choiceContainer);
		$.plot($("#flotResponseTimesOverTime"), dataset, options);
		
		// setup overview
		$.plot($("#overviewResponseTimesOverTime"), dataset, overviewOptions);
	}
};

//Latencies Over Time
function lot(bool) {
			var data = ${latenciesOverTime.values};
			var options = {
				series: {
					lines: {
						show: true
					},
					points: {
						show: true
					}
				},
				xaxis: {
					min: ${latenciesOverTime.minX?c} + ${timeZoneOffset?c},
					max: ${latenciesOverTime.maxX?c} + ${timeZoneOffset?c},
					mode: "time",
					timeformat: "%H:%M:%S",
					axisLabel: getElapsedTimeLabel(${latenciesOverTime.granularity?c}),
					axisLabelUseCanvas: true,
					axisLabelFontSizePixels: 12,
					axisLabelFontFamily: 'Verdana, Arial',
					axisLabelPadding: 20,
				},
				yaxis: {
					min: ${latenciesOverTime.minY?c},
					max: ${latenciesOverTime.maxY?c},
					axisLabel: "Response latencies in ms",
					axisLabelUseCanvas: true,
					axisLabelFontSizePixels: 12,
					axisLabelFontFamily: 'Verdana, Arial',
					axisLabelPadding: 20,
				},
				legend: {
					noColumns: 2,
					show: true,
					container: '#legendLatenciesOverTime'
				},
				selection: {
					mode: "x"
				},
				grid: {
					hoverable: true //IMPORTANT! this is needed for tooltip to work
				},
				tooltip: true,
				tooltipOpts: {
					content: "%s for %x was %y"
				}
			};

			// hard-code color indices to prevent them from shifting as
			// countries are turned on/off
			var i = 0;
			$.each(data, function(key, val) {
				val.color = i;
				++i;
			});
			
			fixTimeStamps(data, ${timeZoneOffset?c});
			
			// insert checkboxes
			var dataset = [];
			var choiceContainer = $("#choicesLatenciesOverTime");
			if( bool == false ) {
				plotAccordingToChoices();
			}else {
				createLegend(data, choiceContainer);
				choiceContainer.find("input").click(plotAccordingToChoices);
				plotAccordingToChoices();
				setGraphZoomable("#flotLatenciesOverTime", "#overviewLatenciesOverTime", options);
				$('#footerLatencies .legendColorBox > div').each(function(i){
					$(this).clone().prependTo(choiceContainer.find("li").eq(i));
				});
			}
			function plotAccordingToChoices() {
				dataset = prepareData( data, choiceContainer);
				$.plot($("#flotLatenciesOverTime"), dataset, options);
				
				// setup overview
				$.plot("#overviewLatenciesOverTime", dataset, overviewOptions);
			}
};

//Response Time vs Request
function rtvr(bool) {
		var data = ${responseTimeVsRequest.values};

        var options = {
            series: {
                lines: {
                    show: false
                },
                points: {
                    show: true
                }
            },
			xaxis: {
				min : ${responseTimeVsRequest.minX?c},
				max : ${responseTimeVsRequest.maxX?c},
				axisLabel: "Global number of requests per second",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20,
            },
			yaxis: {
				min : ${responseTimeVsRequest.minY?c},
				max : ${responseTimeVsRequest.maxY?c},
				axisLabel: "Median Response Time",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20,
			},
			legend: {
				noColumns: 2,
				show: true,
				container: '#legendResponseTimeVsRequest'
			},
			grid: {
                hoverable: true //IMPORTANT! this is needed for tooltip to work
            },
            tooltip: true,
            tooltipOpts: {
                content: "%s for %x was %y",
                onHover: function(flotItem, $tooltipEl) {
                }
            }
        };
      
		var choiceContainer = $("#choicesResponseTimeVsRequest");
		if ( bool == false){
			plotAccordingToChoices();
		}else{
			createLegend(data, choiceContainer);
			choiceContainer.find("input").click(plotAccordingToChoices);
	
			plotAccordingToChoices();
			$('#footerRTVR .legendColorBox > div').each(function(i){
				$(this).clone().prependTo(choiceContainer.find("li").eq(i));
			});
		}
		function plotAccordingToChoices() {
			$.plot($("#flot-response-time-vs-request"), prepareData( data, choiceContainer), options);
		}
};


//Latency vs Request
function lvr(bool) {
		var data = ${latencyVsRequest.values};
        var options = {
            series: {
                lines: {
                    show: false
                },
                points: {
                    show: true
                }
            },
			xaxis: {
				min : ${latencyVsRequest.minX?c},
				max : ${latencyVsRequest.maxX?c},
				axisLabel: "Global number of requests per second",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20,
            },
			yaxis: {
				min : ${latencyVsRequest.minY?c},
				max : ${latencyVsRequest.maxY?c},
				axisLabel: "Median Latency",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20,
			}
			,
			legend: { noColumns: 2,show: true, container: '#legendLatencyVsRequest' },
			
			grid: {
                hoverable: true //IMPORTANT! this is needed for tooltip to work
            },
            tooltip: true,
            tooltipOpts: {
                content: "%s for %x was %y",
                onHover: function(flotItem, $tooltipEl) {
                }
            }
        };
      
		var choiceContainer = $("#choicesLatencyVsRequest");
		if(bool == false){
			plotAccordingToChoices();
		}else{
			createLegend(data, choiceContainer);
			choiceContainer.find("input").click(plotAccordingToChoices);
	
			plotAccordingToChoices();
			$('#footerLatency .legendColorBox > div').each(function(i){
				$(this).clone().prependTo(choiceContainer.find("li").eq(i));
			});
		}
		function plotAccordingToChoices() {
			$.plot($("#flot-latency-vs-request"), prepareData( data, choiceContainer), options);
		}
};


//Hits per second
function bbq(bool) {
	var data = ${hitsPerSecond.values};
	var options = {
    	series: {
        	lines: {
            	show: true
            },
            points: {
            	show: true
            }
		},
		xaxis: {
			min: ${hitsPerSecond.minX?c} + ${timeZoneOffset?c},
			max: ${hitsPerSecond.maxX?c} + ${timeZoneOffset?c},
        	mode: "time",
        	timeformat: "%H:%M:%S",
			axisLabel: getElapsedTimeLabel(${hitsPerSecond.granularity?c}),
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
		},
		yaxis: {
			min: ${hitsPerSecond.minY?c},
			max: ${hitsPerSecond.maxY?c},
			axisLabel: "Number of hits / sec",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20 
		},
		legend: {
			noColumns: 2,
			show: true, 
			container: "#legendHitsPerSecond"},
		grid: {
        	hoverable: true //IMPORTANT! this is needed for tooltip to work
		},
        tooltip: true,
        tooltipOpts: {
			content: "%s for %x was %y.2"
		}
	};
        
	fixTimeStamps(data, ${timeZoneOffset?c});
		
	var dataset = [];
	var choiceContainer = $("#choicesHitsPerSecond");
	if (bool ==false){
		plotAccordingToChoices();
	}else{
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		setGraphZoomable("#flotHitsPerSecond", "#overviewHitsPerSecond", options);
		$('#footerHitsPerSecond .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
	function plotAccordingToChoices() {
		dataset = prepareData(data, choiceContainer);
		plot = $.plot($("#flotHitsPerSecond"), dataset, options);
	
		// setup overview
		$.plot($("#overviewHitsPerSecond"), dataset, overviewOptions);
	}
}


//Hits codes per second
function hcps(bool) {
	var data = ${codesPerSecond.values};
	var options = {
        series: {
            lines: {
                show: true
            },
            points: {
                show: true
            }
        },
		xaxis: {
			min: ${codesPerSecond.minX?c} + ${timeZoneOffset?c},
			max: ${codesPerSecond.maxX?c} + ${timeZoneOffset?c},
            mode: "time",
			timeformat: "%H:%M:%S",
			axisLabel: getElapsedTimeLabel(${codesPerSecond.granularity?c}),
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
        },
		yaxis: {
			min: ${codesPerSecond.minY?c},
			max: ${codesPerSecond.maxY?c},
			axisLabel: "Number of responses/sec",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
		},
		legend: {
			noColumns: 2,
			show: true, 
			container: "#legendCodesPerSecond"},			
		grid: {
            hoverable: true //IMPORTANT! this is needed for tooltip to work
        },
        tooltip: true,
        tooltipOpts: {
            content: "%s for %x was %y.2"
        }
    };

    // hard-code color indices to prevent them from shifting as
	// countries are turned on/off
	var i = 0;
	$.each(data, function(key, val) {
		val.color = i;
		++i;
	});
	
	fixTimeStamps(data, ${timeZoneOffset?c});
	
	var dataset = [];
	var choiceContainer = $("#choicesCodesPerSecond");
	if( bool == false){
		plotAccordingToChoices();
	}else{
		createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		setGraphZoomable("#flotCodesPerSecond", "#overviewCodesPerSecond", options);
		$('#footerCodesPerSecond .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
	function plotAccordingToChoices() {
		dataset = prepareData( data, choiceContainer);
		$.plot($("#flotCodesPerSecond"), dataset, options);
		
		// setup overview
		$.plot($("#overviewCodesPerSecond"), dataset, overviewOptions);
	}
};


// Transactions per second
function tps(bool) {
	var data = ${transactionsPerSecond.values};
	var options = {
        series: {
            lines: {
                show: true
            },
            points: {
                show: true
            }
        },
		xaxis: {
			min: ${transactionsPerSecond.minX?c} + ${timeZoneOffset?c},
			max: ${transactionsPerSecond.maxX?c} + ${timeZoneOffset?c},
            mode: "time",
			timeformat: "%H:%M:%S",
			axisLabel: getElapsedTimeLabel(${transactionsPerSecond.granularity?c}),
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,
        },
		yaxis: {
			min: ${transactionsPerSecond.minY?c},
			max: ${transactionsPerSecond.maxY?c},
			axisLabel: "Number of transactions / sec",
            axisLabelUseCanvas: true,
            axisLabelFontSizePixels: 12,
            axisLabelFontFamily: 'Verdana, Arial',
            axisLabelPadding: 20,			}
		,
		legend: {
			noColumns: 2,
			show: true, 
			container: "#legendTransactionsPerSecond"},
		grid: {
            hoverable: true //IMPORTANT! this is needed for tooltip to work
        },
        tooltip: true,
        tooltipOpts: {
            content: "%s for %x was %y"
        }
    };

    // hard-code color indices to prevent them from shifting as
    // countries are turned on/off
    var i = 0;
    $.each(data, function(key, val) {
        val.color = i;
        ++i;
    });
    
    fixTimeStamps(data, ${timeZoneOffset?c});
    
    var dataset = [];
    var choiceContainer = $("#choicesTransactionsPerSecond");
	if( bool == false){
		plotAccordingToChoices();
	}else{
    	createLegend(data, choiceContainer);
		choiceContainer.find("input").click(plotAccordingToChoices);
		plotAccordingToChoices();
		setGraphZoomable("#flotTransactionsPerSecond", "#overviewTransactionsPerSecond", options);
		$('#footerTransactions .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
    
    function plotAccordingToChoices() {
    	dataset = prepareData( data, choiceContainer);
    	$.plot($("#flotTransactionsPerSecond"), dataset, options);
    	
    	// setup overview
		$.plot($("#overviewTransactionsPerSecond"), dataset, overviewOptions);
    }
};

//collapse
$(function() {
		$('.collapse').on('shown.bs.collapse', function(){
			$(this).parent().find(".fa-chevron-down").removeClass("fa-chevron-down").addClass("fa-chevron-up");
			if (this.id == "bodyResponseTimeOver") {
				if ( b6 == false ) {
					rtot();
				}
				b6 = true;
				document.location.href="#responseTimesOverTime";
			} else if (this.id == "bodyLantencies") {
				if ( b5 == false ) {
					lot();
				}
				b5 = true;
				document.location.href="#latenciesOverTime";
			} else if (this.id == "bodyRTD") {
				if ( b1 == false ) {
					rtd();
				}
				b1 = true;
				document.location.href="#responseTimeDistribution" ;
			} else if (this.id == "bodyTSOT") {
				if ( b2 == false ) {
					tsot();
				}
				b2 = true;
				document.location.href="#activeThreadsOverTime";
			} else if (this.id == "bodyRTPS") {
				if ( b3 == false ) {
					hb();
				}
				b3 = true;
				document.location.href="#responseTimePerSample" ;
			} else if (this.id == "bodyTVT") {
				if ( b4 == false ) {
					tvt();
				}
				b4 = true;
				document.location.href="#timeVsThreads" ;
			} else if (this.id == "bodyCodesPerSecond") {
				if ( b7 == false ) {
					hcps();
				}
				b7 = true;
				document.location.href="#codesPerSecond";
			} else if (this.id == "bodyTransactionspersecond") {
				if ( b8 == false ) {
					tps();
				}
				b8 = true;
				document.location.href="#transactionsPerSecond";
			} else if (this.id == "bodyResponseTimeVsRequest") {
				if ( b9 == false ) {
					rtvr();
				}
				b9 = true;
				document.location.href="#responseTimeVsRequest";
			} else if (this.id == "bodylatency") {
				if ( b10 == false ) {
					lvr();
				}
				b10 = true;
				document.location.href="#latencyVsRequest";
			}
		}).on('hidden.bs.collapse', function(){
			$(this).parent().find(".fa-chevron-up").removeClass("fa-chevron-up").addClass("fa-chevron-down");
			var d = $(this);
		});
});

$(function() {
	$(".glyphicon").mousedown( function(event){
		var tmp = $('.in:not(ul)');
		tmp.parent().parent().parent().find(".fa-chevron-up").removeClass("fa-chevron-down").addClass("fa-chevron-down");
		tmp.removeClass("in");
		tmp.addClass("out");
	});
});

function toggleAll(id, checked){
	var placeholder = document.getElementById(id);
	
	var cases = $(placeholder).find(':checkbox');
  
	cases.attr('checked', checked);
	$(cases).parent().children().children().toggleClass("legend-disabled", !checked);
	
	var choiceContainer;
	if ( id == "choicesBytesThroughputOverTime"){
		choiceContainer = $("#choicesBytesThroughputOverTime");
		btot(false);
	} else if(id == "choicesResponseTimesOverTime"){
		choiceContainer = $("#choicesResponseTimesOverTime");
		rtot(false);
	} else if ( id == "choicesLatenciesOverTime"){
		choiceContainer = $("#choicesLatenciesOverTime");
		lot(false);
	} else if ( id == "choicesResponseTimePercentiles"){
		choiceContainer = $("#choicesResponseTimePercentiles");
		rtp(false);
	} else if(id == "choicesActiveThreadsOverTime"){
		choiceContainer = $("#choicesActiveThreadsOverTime");
		tsot(false);
	} else if ( id == "choicesTimeVsThreads"){
		choiceContainer = $("#choicesTimeVsThreads");
		tvt(false);
	} else if ( id == "choicesResponseTimeDistribution"){
		choiceContainer = $("#choicesResponseTimeDistribution");
		rtd(false);
	} else if ( id == "choicesResponseTimePerSample"){
		choiceContainer = $("#choicesResponseTimePerSample");
		hb(false);
	} else if ( id == "choicesHitsPerSecond"){
		choiceContainer = $("#choicesHitsPerSecond");
		bbq(false);
	} else if(id == "choicesCodesPerSecond"){
		choiceContainer = $("#choicesCodesPerSecond");
		hcps(false);
	} else if ( id == "choicesTransactionsPerSecond"){
		choiceContainer = $("#choicesTransactionsPerSecond");
		tps(false);
	} else if ( id == "choicesResponseTimeVsRequest"){
		choiceContainer = $("#choicesResponseTimeVsRequest");
		rtvr(false);
	} else if ( id == "choicesLatencyVsRequest"){
		choiceContainer = $("#choicesLatencyVsRequest");
		lvr(false);
	}
	var color = checked ? "black" : "#818181";
	choiceContainer.find("label").each(function(){
		this.style.color = color;
	});
}

//uncheck all boxes
function uncheckAll(id){
	toggleAll(id, false);
}

//check all boxes
function checkAll(id){
	toggleAll(id, true);
}

//prepare datas
function prepareData(data, choiceContainer){
	var datasets = [];
	choiceContainer.find("input:checked").each(function () {
		var key = $(this).attr("name");
		if (key == data[key].label)
			datasets.push(data[key]);
	});
	return datasets;
}

//create slider
$(function() {
    $( "#slider-vertical" ).slider({
      orientation: "vertical",
      range: "min",
      min: ${responseTimePercentiles.minY?c},
      max: ${responseTimePercentiles.maxY?c},
      value: 0,
      slide: function( event, ui ) {
       chiffre= ui.value;
	   rtp(false,ui.value);
	   $( "#amount" ).val( ui.value );
      }
    });
    $("#amount" ).val( $( "#slider-vertical" ).slider( "value" ) );
	$("#slider-vertical").children("div").css("background-color","purple");
	$("#amount" ).css("color", $("#slider-vertical").children("div").css("background-color"));
	$("#slider-vertical").children("div").css("opacity","0.3");
});


function sortAlphaCaseless(a,b){
    return a.toLowerCase() > b.toLowerCase() ? 1 : -1;
};
 
function createLegend(data, choiceContainer) {
    var keys = Object.keys(data);
    keys.sort(sortAlphaCaseless);
	$.each(keys, function(index, key) {
		var l = data[key].label;
		var li = $('<li />').appendTo(choiceContainer);
			
		$('<input name="' + l + '" id="' + l + '" type="checkbox" checked="checked" hidden />').appendTo(li);
		$('<label>', {
			text: l , 
			'for': l
		}).appendTo(li);
	});
	choiceContainer.find("label").click( function(){
		if ( this.style.color !== "rgb(129, 129, 129)" ){
			this.style.color="#818181";
			var v = $(this).parent();
			$(v).children().children().toggleClass("legend-disabled");
		}else {
			this.style.color="black";
			var i = 0;
			var v = $(this).parent();
			v = $(v).children().children().toggleClass("legend-disabled");
		}
	});
		
	choiceContainer.find("label").mousedown( function(event){
		event.preventDefault();
	});
		
	choiceContainer.find("label").mouseenter( function(){
		this.style.cursor="pointer";
	});
}