$(document).ready(function() {
    
	$(".click-title").mouseenter( function(	e){
		e.preventDefault();
		this.style.cursor="pointer";
	});
	$(".click-title").mousedown( function(event){
		event.preventDefault();
	});
	
	try{
		refreshHitsPerSecond();
	} catch(e){}
	try{
		refreshBytesThroughputOverTime();
	} catch(e){}
	try{
		refreshResponseTimePercentiles();
	} catch(e){}
	$(".portlet-header").css("cursor", "auto");
});

var chiffre = 0;

var overviewOptions = {
	series: {
		lines: { show: true, lineWidth: 1 },
		shadowSize: 0
	},
	xaxis: {
		ticks: 2,
		mode: "time",
		timeformat: "%H:%M:%S",
	},
	yaxis: {
		ticks: 2
	},
	grid: {
		color: "#999"
	},
	selection: {
		mode: "xy"
	},
	legend: {
		show: false
	}
};

// Fixes time stamps
function fixTimeStamps(data, offset){
	$.each(data, function(key, val) {
		$.each(val.data, function(index, coord) {
			coord[0] += offset;
		});
	});
}

// Checked if the specified jquery object is a graph
function isGraph(object){
	return object.data('plot') !== undefined;
}

// Tie each series of the specified data to a color
function setColorIndices(data){
	var i = 0;
    $.each(data, function(key, val) {
        val.color = i;
        ++i;
    });
}

// Set the zoom on the specified plot object
function zoomPlot(plot, xmin, xmax, ymin, ymax){
	var axes = plot.getAxes();
	// Override axes min and max options
	$.extend(true, axes, {
		xaxis: { 
			options : { min: xmin, max: xmax }
		},
		yaxis: { 
			options : { min: ymin, max: ymax }
		}
	});
	
	// Redraw the plot
	plot.setupGrid();
	plot.draw();
}

// Prepares DOM items to add zoom on the specified graph
function setGraphZoomable(graphSelector, overviewSelector){
	var graph = $(graphSelector);
	var overview = $(overviewSelector);
	 
	// Ignore mouse down event
	graph.bind("mousedown", function() { return false; });
	overview.bind("mousedown", function() { return false; });
	
	// Zoom on selection
	graph.bind("plotselected", function (event, ranges) {
		// clamp the zooming to prevent infinite zoom
		if (ranges.xaxis.to - ranges.xaxis.from < 0.00001) {
			ranges.xaxis.to = ranges.xaxis.from + 0.00001;
		}
		if (ranges.yaxis.to - ranges.yaxis.from < 0.00001) {
			ranges.yaxis.to = ranges.yaxis.from + 0.00001;
		}
		
		// Do the zooming
		var plot = graph.data('plot');
		zoomPlot(plot, ranges.xaxis.from, ranges.xaxis.to, ranges.yaxis.from, ranges.yaxis.to);
		plot.clearSelection();
		
		// Synchronize overview selection
		overview.data('plot').setSelection(ranges, true);
	});
	
	// Zoom linked graph on overview selection
	overview.bind("plotselected", function (event, ranges) {
		graph.data('plot').setSelection(ranges);
	});
	
	// Reset linked graph zoom when reseting overview selection
	overview.bind("plotunselected", function () {
		var overviewAxes = overview.data('plot').getAxes();
		zoomPlot(graph.data('plot'), overviewAxes.xaxis.min, overviewAxes.xaxis.max, overviewAxes.yaxis.min, overviewAxes.yaxis.max);
	});
}

var responseTimePercentilesInfos = {
		data: ${responseTimePercentiles.values},
	    options: {
	        series: {
	            points: { show: false }
	        },
	        legend: {
	        	noColumns: 2,
	        	show: true,
	        	container: '#legendResponseTimePercentiles'
	        },
	        xaxis: {
	        	min: ${responseTimePercentiles.minX?c},
				max: ${responseTimePercentiles.maxX?c},
				tickDecimals: 1,
				axisLabel: "Percentiles",
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
			},
	        yaxis: { 
				min: ${responseTimePercentiles.minY?c},
				max: ${responseTimePercentiles.maxY?c},
				axisLabel: "Percentile value in ms",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
				
			},
			grid: {
	            hoverable: true // IMPORTANT! this is needed for tooltip to work
	        },
	        tooltip: true,
	        tooltipOpts: {
	            content: "%s for %x.2 was %y"
	        },
	        selection: { mode: "x" },
			stack: true
	    },
	    createGraph: function() {
			var data = this.data;
	    	var dataset = [];
			var i = 0;
			$("#choicesResponseTimePercentiles").find("input:checked").each(function () {
				var key = $(this).attr("name");
				if (key == data[key].label){
					dataset.push(data[key]);
					dataset[i].threshold.below=chiffre;
					dataset[i].threshold.color=$("#slider-vertical").children("div").css("background-color");
					i++;
				}
			});

			$.plot($("#flotResponseTimesPercentiles"), dataset, this.options);
			$("#collapseResponseTimePercentiles #legendResponseTimePercentiles").children().css("border", "1px solid #888888");
		}
};
	
// Response times percentiles
function refreshResponseTimePercentiles(below) {
	var  infos = responseTimePercentilesInfos;
	setColorIndices(infos.data);
	if (isGraph($("#flotResponseTimesPercentiles"))){
		infos.createGraph();
	} else {
		var choiceContainer = $("#choicesResponseTimePercentiles");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		$('#bodyResponseTimePercentiles .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
}

var responseTimeDistributionInfos = {
		data: ${responseTimeDistribution.values},
		options: {
			legend: { noColumns: 2,show: true, container: '#legendResponseTimeDistribution' },
			xaxis:{
				axisLabel: "Response times in ms",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
			},
			yaxis: {
				axisLabel: "Number of responses",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
			},
			bars : {
				show: true,
				barWidth: ${responseTimeDistribution.granularity?c}
			},
			grid: {
	            hoverable: true // IMPORTANT! this is needed for tooltip to work
	        },
	        tooltip: true,
	        tooltipOpts: {
	            content: function(label, xval, yval, flotItem){
	            	return yval + " responses for " + label + " were between " + xval + " and " + (xval + ${responseTimeDistribution.granularity?c}) + " ms";
	            }
	        }
	    },
		createGraph: function() {
			$.plot($("#flotResponseTimeDistribution"), prepareData(this.data, $("#choicesResponseTimeDistribution")), this.options);
		}
	
};

// Response time distribution
function refreshResponseTimeDistribution() {
	var infos = responseTimeDistributionInfos;
	setColorIndices(infos.data);
	if (isGraph($("#flotResponseTimeDistribution"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesResponseTimeDistribution");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		$('#footerResponseTimeDistribution .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

var activeThreadsOverTimeInfos = {
		data: ${activeThreadsOverTime.values},
		options: {
	        series: {
	            lines: {
	                show: true
	            },
	            points: {
					show: true
	            }
	        },
			xaxis: {
				min: ${activeThreadsOverTime.minX?c} + ${timeZoneOffset?c},
				max: ${activeThreadsOverTime.maxX?c} + ${timeZoneOffset?c},
	            mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${activeThreadsOverTime.granularity?c}),
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
	        },
			yaxis: { 
				min: ${activeThreadsOverTime.minY?c},
				max: ${activeThreadsOverTime.maxY?c},
				axisLabel: "Number of active threads",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20
	        },
			legend: {
				noColumns: 6,
				show: true,
				container: '#legendActiveThreadsOverTime'
			},
			grid: {
	            hoverable: true // IMPORTANT! this is needed for tooltip to work
	        },
	        selection: {
	        	mode: 'xy'
	        },
	        tooltip: true,
	        tooltipOpts: {
	            content: "%s for %x was %y"
	        }
	    },
	    createGraph: function() {
			var dataset = prepareData(this.data, $("#choicesActiveThreadsOverTime"));
			var options = this.options;
			$.plot($("#flotActiveThreadsOverTime"), dataset, options);
			// setup overview
			$.plot($("#overviewActiveThreadsOverTime"), dataset, $.extend(true, {}, overviewOptions, {
				xaxis: {min : options.xaxis.min, max: options.xaxis.max},
				yaxis: {min : options.yaxis.min, max: options.yaxis.max},
			}));
		}
};

// Active Threads Over Time
function refreshActiveThreadsOverTime() {
	var infos = activeThreadsOverTimeInfos;
	setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
	if(isGraph($("#flotActiveThreadsOverTime"))) {
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesActiveThreadsOverTime");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotActiveThreadsOverTime", "#overviewActiveThreadsOverTime");
		$('#footerActiveThreadsOverTime .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

var responseTimePerSampleInfos = {
		data: ${responseTimePerSample.values},
	    options: {
			series: {
	        	bars: {
	            	 show: true
				}
			},
			bars: {
				align: "center",
				barWidth: 0.5,
				horizontal: true,
				fillColor: { colors: [{ opacity: 0.5 }, { opacity: 1}] },
				lineWidth: 1
			},
			xaxis: {
				max: ${responseTimePerSample.maxX?c},
				axisLabel: "Response Time in ms",
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,
				tickColor: "white",
				tickFormatter: function (v, axis) {
					return $.formatNumber(v, { format: "#,###", locale: "us" });
				},
				color: "black"
			},
			yaxis: {
				tickColor: "white",
				ticks: ${responseTimePerSample.sampleNames},
				color: "black"
			},
			legend: {
				noColumns: 0,
				labelBoxBorderColor: "#858585",
				container: '#legendHorizontalBar'
			},
			grid: {
				hoverable: true,
				borderWidth: 2,
				backgroundColor: { colors: ["white", "white"] }
			}
		},
	    createGraph: function() {
			$.plot($("#flotResponseTimePerSample"), prepareData(this.data, $("#choicesResponseTimePerSample")), this.options);
		}

};

// Response Time Per Sample
function refreshResponseTimePerSample() {
	var infos = responseTimePerSampleInfos;
	setColorIndices(infos.data);
	if (isGraph($("#flotResponseTimePerSample"))){
		infos.createGraph();
	} else {
		var choiceContainer = $("#choicesResponseTimePerSample");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		$('#footerResponseTimePerSample .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}

    var previousPoint = null, previousLabel = null;
 
	$.fn.UseTooltip = function () {
		$(this).bind("plothover", function (event, pos, item) {
			if (item) {
				if ((previousLabel != item.series.label) ||
					(previousPoint != item.dataIndex)) {
					previousPoint = item.dataIndex;
					previousLabel = item.series.label;
					$("#tooltip").remove();
 
					var x = item.datapoint[0];
					var y = item.datapoint[1];
 
					var color = item.series.color;
 
					showTooltip(item.pageX,
						item.pageY,
                        color,
                        "<strong>" + item.series.label + "</strong><br>" + item.series.yaxis.ticks[y].label +
                        " : <strong>" + $.formatNumber(x, { format: "#,###", locale: "us" }) + "</strong> ms");
				}
			} else {
				$("#tooltip").remove();
				previousPoint = null;
			}
		});
	};
 
	function showTooltip(x, y, color, contents) {
		$('<div id="tooltip">' + contents + '</div>').css({
			position: 'absolute',
			display: 'none',
			top: y - 10,
			left: x + 10,
			border: '2px solid ' + color,
			padding: '3px',
			'font-size': '9px',
			'border-radius': '5px',
			'background-color': '#fff',
			'font-family': 'Verdana, Arial, Helvetica, Tahoma, sans-serif',
			opacity: 0.9
		}).appendTo("body").fadeIn(200);
	}
	
	$("#flotResponseTimePerSample").UseTooltip();
};

var timeVsThreadsInfos = {
		data: ${timeVsThreads.values},
        options: {
            series: {
                lines: {
                    show: true
                },
                points: {
                    show: true
                }
            },
			xaxis: {
				min: ${timeVsThreads.minX?c},
				max: ${timeVsThreads.maxX?c},
                axisLabel: "Number of active threads",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20,
			},
			yaxis: {
				min: ${timeVsThreads.minY?c},
				max: ${timeVsThreads.maxY?c},
                axisLabel: "Average response times in ms",
                axisLabelUseCanvas: true,
                axisLabelFontSizePixels: 12,
                axisLabelFontFamily: 'Verdana, Arial',
                axisLabelPadding: 20
			},
			
			legend: { noColumns: 2,show: true, container: '#legendTimeVsThreads' },
			grid: {
                hoverable: true // IMPORTANT! this is needed for tooltip to work
            },
            tooltip: true,
            tooltipOpts: {
                content: "%s for %x.2 was %y.2",
                onHover: function(flotItem, $tooltipEl) {
                }
            }
        },
		createGraph: function() {
			$.plot($("#flotTimesVsThreads"), prepareData(this.data, $("#choicesTimeVsThreads")), this.options);
		}	
};

// Time vs threads
function refreshTimeVsThreads(){
	var infos = timeVsThreadsInfos;
	setColorIndices(infos.data);
	if(isGraph($("#flotTimesVsThreads"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesTimeVsThreads");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		$('#footerTimeVsThreads .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

var bytesThroughputOverTimeInfos = {
		data: ${bytesThroughputOverTime.values},
		options: {
			series: {
				lines: {
					show: true
				},
				points: {
					show: true
				}
			},
			xaxis: {
				min: ${bytesThroughputOverTime.minX?c} + ${timeZoneOffset?c},
				max: ${bytesThroughputOverTime.maxX?c} + ${timeZoneOffset?c},
				mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${bytesThroughputOverTime.granularity?c}) ,
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,
			},
			yaxis: { 
				min: ${bytesThroughputOverTime.minY?c},
				max: ${bytesThroughputOverTime.maxY?c},
				axisLabel: "Bytes/sec",
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,			
			},
			legend: {
				noColumns: 2,
				show: true,
				container: '#legendBytesThroughputOverTime'
			},
			selection: { 
				mode: "xy"
			},
			grid: {
				hoverable: true // IMPORTANT! this is needed for tooltip to work
			},
			tooltip: true,
			tooltipOpts: {
				content: "%s for %x was %y"
			}
		},
		createGraph: function() {
			var dataset = prepareData(this.data, $("#choicesBytesThroughputOverTime"));
			var options = this.options;
			$.plot($("#flotBytesThroughputOverTime"), dataset, options);
			// setup overview
			$.plot($("#overviewBytesThroughputOverTime"), dataset, $.extend(true, {}, overviewOptions, {
				xaxis: {min : options.xaxis.min, max: options.xaxis.max},
				yaxis: {min : options.yaxis.min, max: options.yaxis.max},
			}));
		}
};

// Bytes throughput Over Time
function refreshBytesThroughputOverTime() {
	var infos = bytesThroughputOverTimeInfos;
	setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
	if(isGraph($("#flotBytesThroughputOverTime"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesBytesThroughputOverTime");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotBytesThroughputOverTime", "#overviewBytesThroughputOverTime");
		$('#footerBytesThroughputOverTime .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
}

var responseTimesOverTimeInfos = {
		data: ${responseTimesOverTime.values},
		options: {
	        series: {
	            lines: {
	                show: true
	            },
	            points: {
	                show: true
	            }
	        },
			xaxis: {
				min: ${responseTimesOverTime.minX?c} + ${timeZoneOffset?c},
				max: ${responseTimesOverTime.maxX?c} + ${timeZoneOffset?c},
	            mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${responseTimesOverTime.granularity?c}),
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
	        },
			yaxis: { 
				min: ${responseTimesOverTime.minY?c},
				max: ${responseTimesOverTime.maxY?c},
				axisLabel: "Response time in ms",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
			},
			legend: {
				noColumns: 2,
				show: true,
				container: '#legendResponseTimesOverTime'
			},
			selection: {
	        	mode: 'xy'
	        },
	        grid: {
	            hoverable: true // IMPORTANT! this is needed for tooltip to work
	        },
	        tooltip: true,
	        tooltipOpts: {
	            content: "%s for %x was %y"
	        }
	    },
	    createGraph: function() {
			var dataset = prepareData(this.data, $("#choicesResponseTimesOverTime"));
			var options = this.options;
			$.plot($("#flotResponseTimesOverTime"), dataset, options);
			// setup overview
			$.plot($("#overviewResponseTimesOverTime"), dataset, $.extend(true, {}, overviewOptions, {
				xaxis: {min : options.xaxis.min, max: options.xaxis.max},
				yaxis: {min : options.yaxis.min, max: options.yaxis.max},
			}));
		}
};

// Response Times Over Time
function refreshResponseTimeOverTime() {
	var infos = responseTimesOverTimeInfos;
    setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
	if(isGraph($("#flotResponseTimesOverTime"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesResponseTimesOverTime");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotResponseTimesOverTime", "#overviewResponseTimesOverTime");
		$('#footerResponseTimesOverTime .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

var latenciesOverTimeInfos = {
		data: ${latenciesOverTime.values},
		options: {
			series: {
				lines: {
					show: true
				},
				points: {
					show: true
				}
			},
			xaxis: {
				min: ${latenciesOverTime.minX?c} + ${timeZoneOffset?c},
				max: ${latenciesOverTime.maxX?c} + ${timeZoneOffset?c},
				mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${latenciesOverTime.granularity?c}),
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,
			},
			yaxis: {
				min: ${latenciesOverTime.minY?c},
				max: ${latenciesOverTime.maxY?c},
				axisLabel: "Response latencies in ms",
				axisLabelUseCanvas: true,
				axisLabelFontSizePixels: 12,
				axisLabelFontFamily: 'Verdana, Arial',
				axisLabelPadding: 20,
			},
			legend: {
				noColumns: 2,
				show: true,
				container: '#legendLatenciesOverTime'
			},
			selection: {
	        	mode: 'xy'
	        },
	        grid: {
				hoverable: true // IMPORTANT! this is needed for tooltip to work
			},
			tooltip: true,
			tooltipOpts: {
				content: "%s for %x was %y"
			}
		},
		createGraph: function () {
			var dataset = prepareData(this.data, $("#choicesLatenciesOverTime"));
			var options = this.options;
			$.plot($("#flotLatenciesOverTime"), dataset, options);
			// setup overview
			$.plot($("#overviewLatenciesOverTime"), dataset, $.extend(true, {}, overviewOptions, {
				xaxis: {min : options.xaxis.min, max: options.xaxis.max},
				yaxis: {min : options.yaxis.min, max: options.yaxis.max},
			}));
		}	
};

// Latencies Over Time
function refreshLatenciesOverTime() {
	var infos = latenciesOverTimeInfos;
	setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
	if(isGraph($("#flotLatenciesOverTime"))) {
		infos.createGraph();
	}else {
		var choiceContainer = $("#choicesLatenciesOverTime");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotLatenciesOverTime", "#overviewLatenciesOverTime");
		$('#footerLatenciesOverTime .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

var responseTimeVsRequestInfos = {
	data: ${responseTimeVsRequest.values},
	options: {
		series: {
			lines: {
				show: false
			},
			points: {
				show: true
			}
		},
		xaxis: {
			min : ${responseTimeVsRequest.minX?c},
			max : ${responseTimeVsRequest.maxX?c},
			axisLabel: "Global number of requests per second",
			axisLabelUseCanvas: true,
			axisLabelFontSizePixels: 12,
			axisLabelFontFamily: 'Verdana, Arial',
			axisLabelPadding: 20,
		},
		yaxis: {
			min : ${responseTimeVsRequest.minY?c},
			max : ${responseTimeVsRequest.maxY?c},
			axisLabel: "Median Response Time",
			axisLabelUseCanvas: true,
			axisLabelFontSizePixels: 12,
			axisLabelFontFamily: 'Verdana, Arial',
			axisLabelPadding: 20,
		},
		legend: {
			noColumns: 2,
			show: true,
			container: '#legendResponseTimeVsRequest'
		},
		grid: {
			hoverable: true // IMPORTANT! this is needed for tooltip to work
		},
		tooltip: true,
		tooltipOpts: {
			content: "%s for %x was %y"
		}
	},
    createGraph: function () {
		$.plot($("#flotResponseRimeVsRequest"), prepareData(this.data, $("#choicesResponseTimeVsRequest")), this.options);
	}	
};

// Response Time vs Request
function refreshResponseTimeVsRequest() {
	var infos = responseTimeVsRequestInfos;
	setColorIndices(infos.data);
	if (isGraph($("#flotResponseRimeVsRequest"))){
		infos.create();
	}else{
		var choiceContainer = $("#choicesResponseTimeVsRequest");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		$('#footerResponseRimeVsRequest .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};


var latenciesVsRequestInfos = {
	data: ${latencyVsRequest.values},
    options: {
    	series: {
        	lines: {
            	show: false
        	},
        	points: {
        		show: true
        	}
    	},
    	xaxis: {
    		min : ${latencyVsRequest.minX?c},
    		max : ${latencyVsRequest.maxX?c},
    		axisLabel: "Global number of requests per second",
    		axisLabelUseCanvas: true,
    		axisLabelFontSizePixels: 12,
    		axisLabelFontFamily: 'Verdana, Arial',
    		axisLabelPadding: 20,
    	},
    	yaxis: {
    		min : ${latencyVsRequest.minY?c},
    		max : ${latencyVsRequest.maxY?c},
    		axisLabel: "Median Latency",
    		axisLabelUseCanvas: true,
    		axisLabelFontSizePixels: 12,
    		axisLabelFontFamily: 'Verdana, Arial',
    		axisLabelPadding: 20,
    	},
    	legend: { noColumns: 2,show: true, container: '#legendLatencyVsRequest' },
    	grid: {
    		hoverable: true // IMPORTANT! this is needed for tooltip to work
    	},
    	tooltip: true,
    	tooltipOpts: {
    		content: "%s for %x was %y"
    	}
	},
	createGraph: function () {
		$.plot($("#flotLatenciesVsRequest"), prepareData(this.data, $("#choicesLatencyVsRequest")), this.options);
	}
};

// Latencies vs Request
function refreshLatenciesVsRequest() {
		var infos = latenciesVsRequestInfos;
		setColorIndices(infos.data);
		if(isGraph($("#flotLatenciesVsRequest"))){
			infos.createGraph();
		}else{
			var choiceContainer = $("#choicesLatencyVsRequest");
			createLegend(choiceContainer, infos);
			infos.createGraph();
			$('#footerLatenciesVsRequest .legendColorBox > div').each(function(i){
				$(this).clone().prependTo(choiceContainer.find("li").eq(i));
			});
		}
};

var hitsPerSecondInfos = {
		data: ${hitsPerSecond.values},
		options: {
	    	series: {
	        	lines: {
	            	show: true
	            },
	            points: {
	            	show: true
	            }
			},
			xaxis: {
				min: ${hitsPerSecond.minX?c} + ${timeZoneOffset?c},
				max: ${hitsPerSecond.maxX?c} + ${timeZoneOffset?c},
	        	mode: "time",
	        	timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${hitsPerSecond.granularity?c}),
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
			},
			yaxis: {
				min: ${hitsPerSecond.minY?c},
				max: ${hitsPerSecond.maxY?c},
				axisLabel: "Number of hits / sec",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20 
			},
			legend: {
				noColumns: 2,
				show: true, 
				container: "#legendHitsPerSecond"},
			selection: {
				mode : 'xy'
			},
			grid: {
	        	hoverable: true // IMPORTANT! this is needed for tooltip to work
			},
	        tooltip: true,
	        tooltipOpts: {
				content: "%s for %x was %y.2"
			}
		},
		createGraph: function createGraph() {
			var dataset = prepareData(this.data, $("#choicesHitsPerSecond"));
			var options = this.options;
			$.plot($("#flotHitsPerSecond"), dataset, options);
			// setup overview
			$.plot($("#overviewHitsPerSecond"), dataset, $.extend(true, {}, overviewOptions, {
				xaxis: {min : options.xaxis.min, max: options.xaxis.max},
				yaxis: {min : options.yaxis.min, max: options.yaxis.max},
			}));
		}
};

// Hits per second
function refreshHitsPerSecond() {
	var infos = hitsPerSecondInfos;
    setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
	if (isGraph($("#flotHitsPerSecond"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesHitsPerSecond");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotHitsPerSecond", "#overviewHitsPerSecond");
		$('#footerHitsPerSecond .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
}

var codesPerSecondInfos = {
		data: ${codesPerSecond.values},
		options: {
	        series: {
	            lines: {
	                show: true
	            },
	            points: {
	                show: true
	            }
	        },
			xaxis: {
				min: ${codesPerSecond.minX?c} + ${timeZoneOffset?c},
				max: ${codesPerSecond.maxX?c} + ${timeZoneOffset?c},
	            mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${codesPerSecond.granularity?c}),
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
	        },
			yaxis: {
				min: ${codesPerSecond.minY?c},
				max: ${codesPerSecond.maxY?c},
				axisLabel: "Number of responses/sec",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
			},
			legend: {
				noColumns: 2,
				show: true, 
				container: "#legendCodesPerSecond"
			},			
			selection: {
				mode: 'xy'
			},
			grid: {
	            hoverable: true // IMPORTANT! this is needed for tooltip to work
	        },
	        tooltip: true,
	        tooltipOpts: {
	            content: "%s for %x was %y.2"
	        }
	    },
	createGraph: function() {
		var dataset = prepareData(this.data, $("#choicesCodesPerSecond"));
		var options = this.options;
		$.plot($("#flotCodesPerSecond"), dataset, options);
		// setup overview
		$.plot($("#overviewCodesPerSecond"), dataset, $.extend(true, {}, overviewOptions, {
			xaxis: {min : options.xaxis.min, max: options.xaxis.max},
			yaxis: {min : options.yaxis.min, max: options.yaxis.max},
		}));
	}
};

// Codes per second
function refreshCodesPerSecond() {
	var infos = codesPerSecondInfos;
	setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
	if(isGraph($("#flotCodesPerSecond"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesCodesPerSecond");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotCodesPerSecond", "#overviewCodesPerSecond");
		$('#footerCodesPerSecond .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

var transactionsPerSecondInfos = {
		data: ${transactionsPerSecond.values},
		options: {
	        series: {
	            lines: {
	                show: true
	            },
	            points: {
	                show: true
	            }
	        },
			xaxis: {
				min: ${transactionsPerSecond.minX?c} + ${timeZoneOffset?c},
				max: ${transactionsPerSecond.maxX?c} + ${timeZoneOffset?c},
	            mode: "time",
				timeformat: "%H:%M:%S",
				axisLabel: getElapsedTimeLabel(${transactionsPerSecond.granularity?c}),
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,
	        },
			yaxis: {
				min: ${transactionsPerSecond.minY?c},
				max: ${transactionsPerSecond.maxY?c},
				axisLabel: "Number of transactions / sec",
	            axisLabelUseCanvas: true,
	            axisLabelFontSizePixels: 12,
	            axisLabelFontFamily: 'Verdana, Arial',
	            axisLabelPadding: 20,			}
			,
			legend: {
				noColumns: 2,
				show: true, 
				container: "#legendTransactionsPerSecond"
			},
			selection: {
	        	mode: 'xy'
	        },
			grid: {
	            hoverable: true // IMPORTANT! this is needed for tooltip to work
	        },
	        tooltip: true,
	        tooltipOpts: {
	            content: "%s for %x was %y"
	        }
	    },
	createGraph: function () {
		var dataset = prepareData(this.data, $("#choicesTransactionsPerSecond"));
		var options = this.options;
		$.plot($("#flotTransactionsPerSecond"), dataset, options);
		// setup overview
		$.plot($("#overviewTransactionsPerSecond"), dataset, $.extend(true, {}, overviewOptions, {
			xaxis: {min : options.xaxis.min, max: options.xaxis.max},
			yaxis: {min : options.yaxis.min, max: options.yaxis.max},
		}));
	}
};

// Transactions per second
function refreshTransactionsPerSecond() {
	var infos = transactionsPerSecondInfos;
    setColorIndices(infos.data);
	fixTimeStamps(infos.data, ${timeZoneOffset?c});
    if(isGraph($("#flotTransactionsPerSecond"))){
		infos.createGraph();
	}else{
		var choiceContainer = $("#choicesTransactionsPerSecond");
		createLegend(choiceContainer, infos);
		infos.createGraph();
		setGraphZoomable("#flotTransactionsPerSecond", "#overviewTransactionsPerSecond", infos.options);
		$('#footerTransactionsPerSecond .legendColorBox > div').each(function(i){
			$(this).clone().prependTo(choiceContainer.find("li").eq(i));
		});
	}
};

// Collapse the graph matching the specified DOM element depending the collapsed
// status
function collapse(elem, collapsed){
	if(collapsed){
		$(elem).parent().find(".fa-chevron-up").removeClass("fa-chevron-up").addClass("fa-chevron-down");
	} else {
		$(elem).parent().find(".fa-chevron-down").removeClass("fa-chevron-down").addClass("fa-chevron-up");
		if (elem.id == "bodyResponseTimeOverTime") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshResponseTimeOverTime();
			}
			document.location.href="#responseTimesOverTime";
		} else if (elem.id == "bodyLantenciesOverTime") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshLatenciesOverTime();
			}
			document.location.href="#latenciesOverTime";
		} else if (elem.id == "bodyResponseTimeDistribution") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshResponseTimeDistribution();
			}
			document.location.href="#responseTimeDistribution" ;
		} else if (elem.id == "bodyActiveThreadsOverTime") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshActiveThreadsOverTime();
			}
			document.location.href="#activeThreadsOverTime";
		} else if (elem.id == "bodyResponseTimePerSample") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshResponseTimePerSample();
			}
			document.location.href="#responseTimePerSample" ;
		} else if (elem.id == "bodyTimeVsThreads") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshTimeVsThreads();
			}
			document.location.href="#timeVsThreads" ;
		} else if (elem.id == "bodyCodesPerSecond") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshCodesPerSecond();
			}
			document.location.href="#codesPerSecond";
		} else if (elem.id == "bodyTransactionsPerSecond") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshTransactionsPerSecond();
			}
			document.location.href="#transactionsPerSecond";
		} else if (elem.id == "bodyResponseTimeVsRequest") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshResponseTimeVsRequest();
			}
			document.location.href="#responseTimeVsRequest";
		} else if (elem.id == "bodyLatenciesVsRequest") {
			if (isGraph($(elem).find('.flot-chart-content')) == false) {
				refreshLatenciesVsRequest();
			}
			document.location.href="#latencyVsRequest";
		}
	}
}

// collapse
$(function() {
		$('.collapse').on('shown.bs.collapse', function(){
			collapse(this, false);
		}).on('hidden.bs.collapse', function(){
			collapse(this, true);
		});
});

$(function() {
	$(".glyphicon").mousedown( function(event){
		var tmp = $('.in:not(ul)');
		tmp.parent().parent().parent().find(".fa-chevron-up").removeClass("fa-chevron-down").addClass("fa-chevron-down");
		tmp.removeClass("in");
		tmp.addClass("out");
	});
});

function toggleAll(id, checked){
	var placeholder = document.getElementById(id);
	
	var cases = $(placeholder).find(':checkbox');
  
	cases.attr('checked', checked);
	$(cases).parent().children().children().toggleClass("legend-disabled", !checked);
	
	var choiceContainer;
	if ( id == "choicesBytesThroughputOverTime"){
		choiceContainer = $("#choicesBytesThroughputOverTime");
		refreshBytesThroughputOverTime();
	} else if(id == "choicesResponseTimesOverTime"){
		choiceContainer = $("#choicesResponseTimesOverTime");
		refreshResponseTimeOverTime();
	} else if ( id == "choicesLatenciesOverTime"){
		choiceContainer = $("#choicesLatenciesOverTime");
		refreshLatenciesOverTime();
	} else if ( id == "choicesResponseTimePercentiles"){
		choiceContainer = $("#choicesResponseTimePercentiles");
		refreshResponseTimePercentiles();
	} else if(id == "choicesActiveThreadsOverTime"){
		choiceContainer = $("#choicesActiveThreadsOverTime");
		refreshActiveThreadsOverTime();
	} else if ( id == "choicesTimeVsThreads"){
		choiceContainer = $("#choicesTimeVsThreads");
		refreshTimeVsThreads();
	} else if ( id == "choicesResponseTimeDistribution"){
		choiceContainer = $("#choicesResponseTimeDistribution");
		refreshResponseTimeDistribution();
	} else if ( id == "choicesResponseTimePerSample"){
		choiceContainer = $("#choicesResponseTimePerSample");
		refreshResponseTimePerSample();
	} else if ( id == "choicesHitsPerSecond"){
		choiceContainer = $("#choicesHitsPerSecond");
		refreshHitsPerSecond();
	} else if(id == "choicesCodesPerSecond"){
		choiceContainer = $("#choicesCodesPerSecond");
		refreshCodesPerSecond();
	} else if ( id == "choicesTransactionsPerSecond"){
		choiceContainer = $("#choicesTransactionsPerSecond");
		refreshTransactionsPerSecond();
	} else if ( id == "choicesResponseTimeVsRequest"){
		choiceContainer = $("#choicesResponseTimeVsRequest");
		refreshResponseTimeVsRequest();
	} else if ( id == "choicesLatencyVsRequest"){
		choiceContainer = $("#choicesLatencyVsRequest");
		refreshLatenciesVsRequest();
	}
	var color = checked ? "black" : "#818181";
	choiceContainer.find("label").each(function(){
		this.style.color = color;
	});
}

// uncheck all boxes
function uncheckAll(id){
	toggleAll(id, false);
}

// check all boxes
function checkAll(id){
	toggleAll(id, true);
}

// prepare datas
function prepareData(data, choiceContainer){
	var datasets = [];
	choiceContainer.find("input:checked").each(function () {
		var key = $(this).attr("name");
		if (key == data[key].label)
			datasets.push(data[key]);
	});
	return datasets;
}

// create slider
$(function() {
    $( "#slider-vertical" ).slider({
      orientation: "vertical",
      range: "min",
      min: ${responseTimePercentiles.minY?c},
      max: ${responseTimePercentiles.maxY?c},
      value: 0,
      slide: function( event, ui ) {
       chiffre= ui.value;
	   refreshResponseTimePercentiles(ui.value);
	   $( "#amount" ).val( ui.value );
      }
    });
    $("#amount" ).val( $( "#slider-vertical" ).slider( "value" ) );
	$("#slider-vertical").children("div").css("background-color","purple");
	$("#amount" ).css("color", $("#slider-vertical").children("div").css("background-color"));
	$("#slider-vertical").children("div").css("opacity","0.3");
});


function sortAlphaCaseless(a,b){
    return a.toLowerCase() > b.toLowerCase() ? 1 : -1;
};
 
function createLegend(choiceContainer, infos) {
    var keys = Object.keys(infos.data);
    keys.sort(sortAlphaCaseless);
	$.each(keys, function(index, key) {
		var label = infos.data[key].label;
		var id = choiceContainer.attr('id') + label;
		$('<li />')
			.append($('<input id="' + id + '" name="' + label + '" type="checkbox" checked="checked" hidden />'))
			.append($('<label />', { 'text': label , 'for': id }))
			.appendTo(choiceContainer);
	});
	choiceContainer.find("label").click( function(){
		if (this.style.color !== "rgb(129, 129, 129)" ){
			this.style.color="#818181";
		}else {
			this.style.color="black";
		}
		$(this).parent().children().children().toggleClass("legend-disabled");
	});
		
	choiceContainer.find("label").mousedown( function(event){
		event.preventDefault();
	});
		
	choiceContainer.find("label").mouseenter(function(){
		this.style.cursor="pointer";
	});
	
	choiceContainer.find("input").click(function(){
		infos.createGraph();
	});
}